#!/bin/bash
# SPDX-License-Identifier: PMPL-1.0-or-later
# cloud-sync-status - Health check for cloud sync services
# Exit codes: 0=healthy, 1=degraded, 2=failed

set -euo pipefail

VERSION="1.0.0"

# Configuration
MOUNTS=(
    "dropbox:/run/media/hyper/eclipse/Cloud/Dropbox"
    "gdrive:/run/media/hyper/eclipse/Cloud/GoogleDrive"
    "onedrive:/run/media/hyper/eclipse/Cloud/OneDrive"
)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Output format
FORMAT="${FORMAT:-text}"
VERBOSE=false
JSON_OUTPUT=""

usage() {
    cat <<EOF
Usage: cloud-sync-status [OPTIONS]

Health check for cloud sync services.

Options:
  -j, --json      Output in JSON format
  -v, --verbose   Show detailed information
  -q, --quiet     Only exit code, no output
  -w, --watch     Continuous monitoring (refresh every 5s)
  --version       Show version
  -h, --help      Show this help

Exit Codes:
  0  All services healthy
  1  Some services degraded
  2  Critical failure

Examples:
  cloud-sync-status              Quick health check
  cloud-sync-status --json       JSON output for scripts
  cloud-sync-status --watch      Live monitoring
  cloud-sync-status --verbose    Detailed status

EOF
}

check_service() {
    local name=$1
    local status

    status=$(systemctl --user is-active "rclone-${name}.service" 2>/dev/null || echo "inactive")
    echo "$status"
}

check_mount() {
    local path=$1

    if mountpoint -q "$path" 2>/dev/null; then
        echo "mounted"
    elif [[ -d "$path" ]]; then
        echo "unmounted"
    else
        echo "missing"
    fi
}

check_rclone_rc() {
    local name=$1
    local port=$2

    if curl -s --connect-timeout 2 "http://localhost:${port}/core/stats" >/dev/null 2>&1; then
        echo "responding"
    else
        echo "unreachable"
    fi
}

get_transfer_stats() {
    local port=$1
    local stats

    stats=$(curl -s --connect-timeout 2 "http://localhost:${port}/core/stats" 2>/dev/null || echo "{}")
    echo "$stats"
}

get_vfs_stats() {
    local port=$1
    local stats

    stats=$(curl -s --connect-timeout 2 "http://localhost:${port}/vfs/stats" 2>/dev/null || echo "{}")
    echo "$stats"
}

check_disk_space() {
    local path=$1
    local usage

    usage=$(df --output=pcent "$path" 2>/dev/null | tail -1 | tr -d '% ')
    echo "${usage:-0}"
}

format_bytes() {
    local bytes=$1

    if [[ $bytes -lt 1024 ]]; then
        echo "${bytes}B"
    elif [[ $bytes -lt 1048576 ]]; then
        echo "$((bytes / 1024))KB"
    elif [[ $bytes -lt 1073741824 ]]; then
        echo "$((bytes / 1048576))MB"
    else
        echo "$((bytes / 1073741824))GB"
    fi
}

run_checks() {
    local exit_code=0
    local healthy=0
    local degraded=0
    local failed=0

    declare -A results

    # Ports for rclone rc
    local -A ports=(
        ["dropbox"]=5572
        ["gdrive"]=5573
        ["onedrive"]=5574
    )

    for mount_spec in "${MOUNTS[@]}"; do
        local name="${mount_spec%%:*}"
        local path="${mount_spec#*:}"
        local port="${ports[$name]:-5572}"

        local service_status=$(check_service "$name")
        local mount_status=$(check_mount "$path")
        local rc_status=$(check_rclone_rc "$name" "$port")
        local disk_usage=$(check_disk_space "$path")

        # Determine overall status
        local status="healthy"
        if [[ "$service_status" != "active" ]]; then
            status="failed"
            ((failed++))
        elif [[ "$mount_status" != "mounted" ]]; then
            status="degraded"
            ((degraded++))
        elif [[ "$rc_status" != "responding" ]]; then
            status="degraded"
            ((degraded++))
        elif [[ $disk_usage -gt 90 ]]; then
            status="degraded"
            ((degraded++))
        else
            ((healthy++))
        fi

        results["${name}_status"]="$status"
        results["${name}_service"]="$service_status"
        results["${name}_mount"]="$mount_status"
        results["${name}_rc"]="$rc_status"
        results["${name}_disk"]="$disk_usage"

        if $VERBOSE; then
            local stats=$(get_transfer_stats "$port")
            results["${name}_stats"]="$stats"
        fi
    done

    # Determine exit code
    if [[ $failed -gt 0 ]]; then
        exit_code=2
    elif [[ $degraded -gt 0 ]]; then
        exit_code=1
    fi

    # Output
    case "$FORMAT" in
        json)
            output_json results[@] "$healthy" "$degraded" "$failed"
            ;;
        quiet)
            # No output
            ;;
        *)
            output_text results[@] "$healthy" "$degraded" "$failed"
            ;;
    esac

    return $exit_code
}

output_text() {
    local -n res=$1
    local healthy=$2
    local degraded=$3
    local failed=$4

    echo
    echo -e "${BLUE}Cloud Sync Status${NC}"
    echo "════════════════════════════════════════"
    echo

    for mount_spec in "${MOUNTS[@]}"; do
        local name="${mount_spec%%:*}"
        local path="${mount_spec#*:}"

        local status="${res[${name}_status]}"
        local service="${res[${name}_service]}"
        local mount="${res[${name}_mount]}"
        local disk="${res[${name}_disk]}"

        local status_color status_icon
        case "$status" in
            healthy)
                status_color="$GREEN"
                status_icon="●"
                ;;
            degraded)
                status_color="$YELLOW"
                status_icon="◐"
                ;;
            failed)
                status_color="$RED"
                status_icon="○"
                ;;
        esac

        echo -e "${status_color}${status_icon}${NC} ${name^}"
        echo -e "  Service: ${service}"
        echo -e "  Mount:   ${mount} (${path})"
        echo -e "  Disk:    ${disk}% used"

        if $VERBOSE && [[ -n "${res[${name}_stats]:-}" ]]; then
            local stats="${res[${name}_stats]}"
            local bytes=$(echo "$stats" | jq -r '.bytes // 0')
            local speed=$(echo "$stats" | jq -r '.speed // 0')
            local transfers=$(echo "$stats" | jq -r '.transfers // 0')
            echo -e "  Transferred: $(format_bytes $bytes)"
            echo -e "  Speed: $(format_bytes $speed)/s"
            echo -e "  Active: ${transfers} transfers"
        fi
        echo
    done

    echo "────────────────────────────────────────"
    echo -e "Summary: ${GREEN}${healthy} healthy${NC}, ${YELLOW}${degraded} degraded${NC}, ${RED}${failed} failed${NC}"
    echo
}

output_json() {
    local -n res=$1
    local healthy=$2
    local degraded=$3
    local failed=$4

    local services_json=""

    for mount_spec in "${MOUNTS[@]}"; do
        local name="${mount_spec%%:*}"
        local path="${mount_spec#*:}"

        [[ -n "$services_json" ]] && services_json+=","

        services_json+=$(cat <<EOF
"${name}": {
  "status": "${res[${name}_status]}",
  "service": "${res[${name}_service]}",
  "mount": "${res[${name}_mount]}",
  "mount_point": "${path}",
  "disk_usage_percent": ${res[${name}_disk]}
}
EOF
)
    done

    cat <<EOF
{
  "version": "${VERSION}",
  "timestamp": "$(date -Iseconds)",
  "summary": {
    "healthy": ${healthy},
    "degraded": ${degraded},
    "failed": ${failed}
  },
  "services": {
    ${services_json}
  }
}
EOF
}

watch_mode() {
    while true; do
        clear
        echo -e "${BLUE}Cloud Sync Monitor${NC} (Ctrl+C to exit)"
        echo "Last update: $(date)"
        echo
        run_checks || true
        sleep 5
    done
}

main() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -j|--json)
                FORMAT="json"
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                FORMAT="quiet"
                shift
                ;;
            -w|--watch)
                watch_mode
                exit 0
                ;;
            --version)
                echo "cloud-sync-status ${VERSION}"
                exit 0
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage >&2
                exit 1
                ;;
        esac
    done

    run_checks
}

main "$@"
